/*
 * https://www.thc.org
 *
 * Destroy all arguments and environment (/proc/<PID>/environ) and make the process
 * appear as a different process in the process list (ps -eF f).
 *
 * This tool does _NOT_ use LD_PRELOAD but ptrace() instead, allowing its
 * magic working on static binaries (like those generated by GoLang).
 *
 * It's library agnostic and directly screws with the Kernel's
 * elf-table (located on the stack) after the return of SYS_execve().
 *
 * Compile:
 *     gcc -o zapper zapper.c
 *
 * Hide arguments:
 *     ./zapper nmap -sS 192.168.0.0/24
 * Hide arguments and rename process 'nmap' to 'blah':
 *     ./zapper -a blah nmap -sS 192.168.0.0/24
 *
 * exec ./zapper -f -a BlahBlub bash -il
 */

// TODO:
// * Follow (-f) from a separate process. At the moment, zapper starts first
//     and is the parent that forks all tracees as child processes.
//     ptrace_scope > 0 prevents the tracer (zapper) to be a separate process
//     that is not a parent of the tracees.
//     We could set prctl(, PR_SET_PTRACER_ANY) in zapper before execve() of the
//     tracee but that flag is not inherited if the tracee forks another process.
//     The way around this to either inject 'prctl(, PR_SET_PTRACER_ANY)' into
//     the tracee or hook SYS_execve() and execute any new process via a
//     trampoline program that sets prctl correctly.
// * -p to zap argv/env from an existing process: Search through .stack
//     and .heap and modify any pointer that points inside argv[] region.
//     Copy old argv[] to unused stack region that Linux creates to randomize
//     its stack.
// * Use spare stack space that Linux creates to randomize .stack
// * Start from /dev/shm and unlink() the binary afterwards to hide binary.
//   Needs trampoline program to also do this for all childs.
// * Periodically rename argv[0]
// * pick argv[0] at random

#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <linux/ptrace.h>
#include <syscall.h>

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <signal.h>

#if __WORDSIZE == 64
#define OAX(reg) (reg).orig_rax
#define AX(reg)  (reg).rax
#define SP(reg)  (reg).rsp
#define IP(reg)  (reg).rip
#else
#define OAX(reg) (reg).orig_eax
#define AX(reg)  (reg).eax
#define SP(reg)  (reg).esp
#define IP(reg)  (reg).eip
#endif

static union u {
    long val;
    char c[sizeof (long)];
} data;

// ANSI color codes.
#define CDR(a)        "\033[0;31m"a"\033[0m"
#define CDG(a)        "\033[0;32m"a"\033[0m"
#define CDY(a)        "\033[0;33m"a"\033[0m"
#define CDB(a)        "\033[0;34m"a"\033[0m"
#define CDM(a)        "\033[0;35m"a"\033[0m"
#define CDC(a)        "\033[0;36m"a"\033[0m"
#define CM(a)         "\033[1;35m"a"\033[0m"
#define CC(a)         "\033[1;36m"a"\033[0m"
#define CW(a)         "\033[1;37m"a"\033[0m"
#define ERREXIT(code, a...) do{fprintf(stderr, a); exit(code);}while(0)
#define XFAIL(expr, a...) do { \
        if (expr) { \
                fprintf(stderr, "%s:%d:%s() ASSERT(%s): ", __FILE__, __LINE__, __func__, #expr); \
                fprintf(stderr, a); \
                exit(255); \
        } \
} while (0)
#ifdef DEBUG
# define DEBUGF(a...) do{fprintf(stderr, "[DEBUG %s:%d] ", __FILE__, __LINE__); fprintf(stderr, a);}while(0)
#else
# define DEBUGF(a...)
#endif

#define GOTOERR(a...) do { \
    DEBUGF(a); \
    goto err; \
} while (0)

char *g_prg_name;
pid_t g_pid;
int g_flags;
pid_t g_pid_master;
pid_t g_pid_zapper;
#define FL_FOLLOW                 (0x01)
#define FL_STAY_ATTACHED          (0x02)
#define FL_FORCE_TRACER_IS_PARENT (0x04)
#define IS_TRACER_IS_PARENT       (0x08)
#define FL_ZAP_ENV                (0x10)
#define IS_SIGNAL_PROXY           (0x20)

static void
dumpfile(const char *file, void *data, size_t n)
{
    FILE *fp;

    fp = fopen(file, "wb");
    fwrite(data, n, 1, fp);
    fclose(fp);
}

static void
init_vars()
{
    g_pid_zapper = getpid();
    g_flags |= FL_STAY_ATTACHED;
    g_flags |= FL_ZAP_ENV;
}

static void
cb_signal(int sig) {
    if (g_pid_master <= 0)
        return;
    kill(g_pid_master, sig);
}

static void
set_proxy_signals(void) {
    g_flags |= IS_SIGNAL_PROXY;
    signal(SIGHUP, cb_signal);
    signal(SIGINT, cb_signal);
    signal(SIGQUIT, cb_signal);
    signal(SIGUSR1, cb_signal);
    signal(SIGUSR2, cb_signal);
    signal(SIGPIPE, cb_signal);
    signal(SIGTERM, cb_signal);
    signal(SIGURG, cb_signal);
    signal(SIGWINCH, cb_signal);
}

static void
usage(void) {
    printf("\
Hide command line arguments and clear the environment of a command.\n\
\n\
./zapper [-fE] [-a name] command ...\n\
  -a <name>  Rename the process to 'name'\n\
  -f         zap all child processes as well (follow)\n\
  -E         Do not zap the environment\n\
\n\
Example - Start ssh but zap all arguments\n\
    $ "CC("./zapper")" "CM("ssh")CDM(" root@myserver.com")"\n\
Example - Start 'nmap', zap all arguments & make nmap appear as 'harmless':\n\
    $ "CC("./zapper")CDC(" -a harmless ")CM("nmap")CDM(" -sCV -F -Pn scanme.nmap.org")"\n\
Example - Hide current shell and all child processes:\n\
    $ "CC("exec ./zapper")CDC(" -f -a harmless ")CM("${SHELL:-bash}")CDM(" -il")"\n\
\n\
"CDY("Join us on Telegram: ")CW("https://t.me/thcorg")"\n\
");

    exit(0);
}
static int
do_getopts(int argc, char *argv[])
{
    int c;
    char buf[4096];
    char dst[sizeof buf];

    while ( (c = getopt(argc, argv, "+a:fcEh")) != -1) {
        switch (c) {
            case 'h':
                usage();
                break;
            case 'E':
                g_flags &= ~FL_ZAP_ENV;
                break;
            case 'a':
                g_prg_name = strdup(optarg);
                break;
            case 'f':
                // 
                g_flags |= (FL_FOLLOW | FL_STAY_ATTACHED | FL_FORCE_TRACER_IS_PARENT);
                break;
            case 'c':
                // Force the child to be the TRACEE.
                // e.g. shell -> zapper -> orig
                g_flags |= FL_FORCE_TRACER_IS_PARENT;
                break;
        }
    }

    if (argv[optind] == NULL)
        usage();
    if (g_prg_name == NULL)
        g_prg_name = argv[optind];

    if (strcmp(argv[0], g_prg_name) != 0) {
        // argv[0] is still 'zapper'. Execute ourself to fake our own argv[0]
        argv[0] = g_prg_name;
        snprintf(buf, sizeof buf, "/proc/%d/exe", getpid());
        realpath(buf, dst);
        // DEBUGF("executing myself as %s: %s\n", argv[0], dst);
        execv(dst, argv);
    }

    return optind;
}

static long long
get_stack_end(pid_t pid)
{
    char buf[16* 1024];
    FILE *fp;
    size_t sz;
    char *ptr;

    snprintf(buf, sizeof buf, "/proc/%d/maps", pid);
    DEBUGF("FILE %s\n", buf);
    XFAIL((fp = fopen(buf, "rb")) == NULL, "fopen(%s): %s\n", buf, strerror(errno));
    XFAIL((sz = fread(buf, 1, sizeof buf, fp)) == 0, "fread()=%zu: %s\n", sz, strerror(errno));
    fclose(fp);

    // DEBUGF("MAPS: %s\n", buf);
    // 7ffeea4f4000-7ffeea54b000 rw-p 00000000 00:00 0                          [stack]
    XFAIL((ptr = strstr(buf, "[stack]")) == NULL, "Stack not found\n");
    *ptr = '\0';
    while (ptr-- > buf) {
        if (*ptr != '\n')
            continue;
        ptr++;
        break;
    }
    XFAIL(ptr == buf, "STACK not found\n");
    XFAIL((ptr = strchr(ptr, '-')) == NULL, "Stack End not found: strchr(-)\n");
    return strtoul(ptr+1, NULL, 16);
}

// Read data from pid@src to dest.
static void
ptpeekcpy(void *dst, pid_t pid, void *src, size_t n)
{
    void *src_end = src + n;

    while (src_end - src >= sizeof (long)) {
        data.val = ptrace(PTRACE_PEEKDATA, pid, src, NULL);
        memcpy(dst, data.c, sizeof (long));
        dst += sizeof (long);
        src += sizeof (long);
    }

    if (src >= src_end)
        return;
    
    // Partial copy
    data.val = ptrace(PTRACE_PEEKDATA, pid, src, NULL);
    memcpy(dst, data.c, src_end - src);
}

static void
ptpokecpy(pid_t pid, void *dst, void *src, size_t n)
{
    void *src_end = src + n;

    while (src_end - src >= sizeof (long)) {
        memcpy(data.c, src, sizeof (long));
        ptrace(PTRACE_POKEDATA, pid, dst, data.val);
        dst += sizeof (long);
        src += sizeof (long);
    }

    if (src >= src_end)
        return;
 
    data.val = ptrace(PTRACE_PEEKDATA, pid, src, NULL);
    memcpy(data.c, src, src_end - src);
    ptrace(PTRACE_POKEDATA, pid, dst, data.val);
}

static void
ptsetoptions(pid_t pid) {
    // execve() delivers an extra TRAP, ignore it:
    // https://manpages.debian.org/bookworm/manpages-dev/ptrace.2.en.html

    XFAIL(ptrace(PTRACE_SETOPTIONS, pid, NULL, PTRACE_O_TRACESYSGOOD | PTRACE_O_EXITKILL | PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK | PTRACE_O_TRACECLONE | PTRACE_O_TRACEEXEC) != 0, "ptrace %s\n", strerror(errno));
}

static pid_t
start_trace_child(const char *orig_prog, char *new_argv[]) {
    char *str;
    int status;

    XFAIL((g_pid = fork()) < 0, "fork(): %s\n", strerror(errno));
    if (g_pid == 0) {
        // CHILD
        ptrace(PTRACE_TRACEME, 0, NULL, NULL);
        execvp(orig_prog, new_argv);

        // Emulate shell's exit string.
        str = getenv("SHELL");
        if (str != NULL) {
            str = strrchr(str, '/');
            if ((str != NULL) && (*str != '\0'))
                str++;
        }

        fprintf(stderr, "%s: %s: %s\n", str?:"", orig_prog, strerror(errno));
        exit(127);
    }

    // PARENT
    g_pid_master = g_pid;
    close(0); // Dont consume any input. Input should reach forked child (orig_prog).
    if (waitpid(g_pid, &status, 0) == -1)
        goto err;
    if (WIFEXITED(status))
        exit(WEXITSTATUS(status));

    ptsetoptions(g_pid);
    set_proxy_signals();

    g_flags |= IS_TRACER_IS_PARENT;

    return g_pid;
err:
    if (g_pid > 0)
        kill(SIGKILL, g_pid);
    return -1;
}

/*
 * Return SYS_execve on success.
 * Return -1 on error
 * Return -2 if g_pid_master exited.
 */
static int
ptrace_until_execve(pid_t *pidp, struct user_regs_struct *regsp, int *status) {
    struct ptrace_syscall_info si;
    int signum;
    siginfo_t sigi;
    pid_t pid = *pidp;
    void *data = NULL;
    unsigned long cpid;

    *status = 0;
    // Continue until execve().
    while(1) {
        if ((pid > 0) && (ptrace(PTRACE_CONT, pid, NULL, data) != 0))
            GOTOERR("ptrace(%d): %s\n", pid, strerror(errno));
        data = NULL;
        if ( (pid = waitpid(-1, status, WUNTRACED)) == -1)
            GOTOERR("waitpid()=%d: %s\n", pid, strerror(errno));
        *pidp = pid;
        if (WIFEXITED(*status)) {
            if (pid == g_pid_master)
                exit(WEXITSTATUS(*status)); // tracee exited. Exit with same error code.
            pid = 0;
            continue;
        }
        if (WIFSIGNALED(*status)) {
            // Tracee was termianted with a signal
            signum = WTERMSIG(*status);
            DEBUGF("Tracee received TERMSIG SIGNAL-%d\n", signum);
            if (pid == g_pid_master) {
                if (signum == SIGSEGV)
                    exit(128 + signum); // Do not generate core dump of zapper.
                // Tracer to commit suicide with same signal as tracee died.
                if (g_flags & IS_SIGNAL_PROXY)
                    signal(signum, SIG_DFL);
                kill(getpid(), signum);
            }
            pid = 0;
            continue;
        }
        if (!WIFSTOPPED(*status)) {
            // SHOULD NOT HAPPEN
            pid = 0;
            continue;
        }
        //  5 = SIGTRAP
        // 17 = SIGCHLD
        // 19 = SIGSTOP
        signum = WSTOPSIG(*status);
        if (! (signum & 0x80)) {
            // Signal was for TRACEE (not tracer)
            DEBUGF("pid=%d received SIGNAL %d for TRACEE (event=%d?)\n", pid, signum, (*status >> 16) & 0xffff);
            if (signum == SIGTRAP) {
                switch ((*status >> 16) & 0xffff) {
                    case PTRACE_EVENT_FORK:  // 1
                    case PTRACE_EVENT_VFORK:
                    case PTRACE_EVENT_CLONE:
                        XFAIL(ptrace(PTRACE_GETEVENTMSG, pid, NULL, &cpid) == -1, "ptrace(%d): %s\n", pid, strerror(errno));
                        DEBUGF("FORK to cpid=%lu\n", cpid);
                        waitpid(cpid, NULL, 0);
                        ptsetoptions(cpid);
                        XFAIL(ptrace(PTRACE_CONT, cpid, NULL, NULL) == -1, "ptrace(%lu): %s\n", cpid, strerror(errno));
                        break;
                    case PTRACE_EVENT_EXEC:  // 4
                        // Catch execve() after returning from syscall.
                        ptrace(PTRACE_SYSCALL, pid, NULL, NULL);
                        pid = 0;
                        break;
                }
                continue;
            }

            // Forward signal to offending process.
            ptrace(PTRACE_GETSIGINFO, pid, NULL, &sigi);
            DEBUGF("SIG-%d to pid %d [%d, %d, %d]\n", signum, pid, sigi.si_signo, sigi.si_code, sigi.si_errno);
            // data = (void *)(int)signum;
            data = (void *)((long)signum);
            continue;
        }

        // DEBUGF("status=%d (sig=%d %d)\n", *status, signum, signum & ~0x80);

        XFAIL(ptrace(PTRACE_GET_SYSCALL_INFO, pid, sizeof si, &si) <= 0, "ptrace(): %s\n", strerror(errno));
        if (ptrace(PTRACE_GETREGS, pid, NULL, regsp) != 0)
            GOTOERR("ptrace(GETREGS, %d): %s\n", pid, strerror(errno));
        if (OAX(*regsp) != SYS_execve)
            ERREXIT(255, "Not SYS_execve()\n"); // CAN NOT HAPPEN. We only trap execve().

        DEBUGF("pid=%d OP #%d %d-%d system\n", pid, si.op, (*status >> 8) & ~0x80, *status & 0xff);
        if (si.op != PTRACE_EVENTMSG_SYSCALL_EXIT)
            continue;
        DEBUGF(" RET=%lld\n", si.exit.rval);
        DEBUGF(" ISERR=%d\n", si.exit.is_error);
        if (si.exit.is_error != 0)
            continue;

        *pidp = pid;
        return SYS_execve;
    }

err:
    return -1; // FATAL
}

static pid_t
start_trace_parent(const char *orig_prog, char *new_argv[], struct user_regs_struct *regsp) {
    pid_t pid;
    pid_t pid_tracee;
    int ret;
    int status;

    // Try ZAPPER to be the CHILD (tracer) and trace the PARENT (tracee)
    // See ptrace_scope
    // https://www.kernel.org/doc/Documentation/security/Yama.txt

    int up[2];
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, up) != 0)
        goto err;

    pid_tracee = getpid();
    g_pid_master = getpid();
    pid = fork();
    if (pid != 0) {
        // PARENT (tracee)

        // Wait for first child to exit. (See Note-#1)
        waitpid(pid, &ret, 0);
        prctl(PR_SET_PTRACER, PR_SET_PTRACER_ANY);

        // Cant use kill(getpid(), SIGSTOP); because of prctl().
        close(up[0]);
        ret = write(up[1], &ret, sizeof ret); // Signal to TRACER that we are ready for ATTACH.
        ret = read(up[1], &ret, sizeof ret); // Wait for TRACER to be ready.
        close(up[1]);

        // Check if CHILD (tracer) successfully attached to us; PARENT (tracee)
        if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) == -1) {
            execvp(orig_prog, new_argv);
            exit(255); // NOT REACHED
        }

        // TRACER failed to trace us.
        kill(pid, SIGKILL);       // Kill the TRACER (if still alive)  
        return -1;
    }
    // CHILD (tracer) (pid == 0)

    // Note-#1: Fork again & let first child exit.
    // This stops SIGCHLD to be send to the real parent when the TRACER exists
    // without us messing with the sigmask.
    pid = fork();
    if (pid != 0)
        exit(0);

    g_pid = getpid();

    // Wait for TRACEE to tell us when we can attach to TRACEE.
    close(up[1]);
    if (read(up[0], &ret, sizeof ret) < 0)
        goto err;

    if (ptrace(PTRACE_ATTACH, pid_tracee, NULL, NULL) != 0)
        goto err;

    //  5 == SIGTRAP
    // 19 == SIGSTOP.
    // 1029 (SIGTRAP | PTRACE_EVENT_EXEC << 8)
    if (waitpid(pid_tracee, &ret, 0) == -1)
        GOTOERR("waitpid(%d): %s\n", pid_tracee, strerror(errno));

    ptsetoptions(pid_tracee);

    // Tell TRACEE that we are attached and TRACEE can call execve().
    if (write(up[0], &ret, sizeof ret) != sizeof ret)
        goto err;

    close(up[0]);
    DEBUGF("Tracing %d\n", pid_tracee);

    ret = ptrace_until_execve(&pid_tracee, regsp, &status);
    if (ret > 0)
        return pid_tracee;
    
err:
    close(up[0]);
    close(up[1]);

    return -1;
}

static void
fix_stack(pid_t pid, struct user_regs_struct *regsp)
{
    size_t stack_sz;
    char *stack;
    unsigned long *stackp;
    unsigned long *stack_envp;
    unsigned long *valp;
    void *stack_sparep = NULL;  // randomized .stack
    size_t stack_spare_sz = 0;
    long long stack_end;
    int elft_idx;
    int idx;
    int n;

    stack_end = get_stack_end(pid);
    // XFAIL(ptrace(PTRACE_GETREGS, pid, NULL, regsp) != 0, "ptrace(%d): %s\n", pid, strerror(errno));

    DEBUGF("=> SP 0x%llx-0x%llx (%llu)\n", SP(*regsp), stack_end, stack_end - SP(*regsp));

    stack_sz = stack_end - SP(*regsp);
    stack = calloc(1, stack_sz);
    XFAIL(stack == NULL, "calloc(): %s\n", strerror(errno));
    stackp = (unsigned long *)stack;
    ptpeekcpy(stack, pid, (void *)SP(*regsp), stack_sz);

    dumpfile("stack.dat", stack, stack_end - SP(*regsp));
    DEBUGF("argc     = %lx\n", stackp[0]);
    DEBUGF("&argv[0] = %lx\n", stackp[1]);
    DEBUGF("argv[0]  = "CDR("%s")"\n",  &stack[stackp[1] - SP(*regsp)]);

    // Fing the length of all command line parameters
    size_t len = 0;
    valp = &stackp[1];
    while (*valp != 0) {
        idx = *valp - SP(*regsp);
        len += strlen(&stack[idx]);
        len++; // \0
        valp++;
    }
    valp++; // Skip NULL
    DEBUGF("Total Length of all command line args: %zu bytes\n", len);

    // Skip through envp and find start of elf-table
    stack_envp = valp;
    while (*valp != 0) {
        if (g_flags & FL_ZAP_ENV) {
            idx = *valp - SP(*regsp);
            len += strlen(&stack[idx]);
            len++; // \0
        }
        valp++;
    }
    valp++; // Skip 0x00

    DEBUGF("stackp 0x%lx valp 0x%lx\n", (unsigned long)stackp, (unsigned long)valp);
    elft_idx = valp - stackp;
    DEBUGF("Elf Table start at idx=%d (+0x%lx)\n", elft_idx, elft_idx * sizeof (void *));

    // Align to 16 bytes boundary
    if (len != (len & ~15))
        len = (len + 16) & ~15;
    DEBUGF("Creating a gap of %zu bytes\n", len);

    // The size we are interested in is all data between SP
    // and the argv-strings + extra space to duplicate the argv-strings
    // => Make a copy and make it 'len' longer.
    stack_sz = stackp[1] - SP(*regsp) + len + len;
    stack = realloc(stack, stack_sz);
    stackp = (unsigned long *)stack;

    // Adjust the elf table that we moved to a lower address by len.
    n = 0;
    while (1)
    {
        idx = elft_idx + n * 2;
        if (stackp[idx] == 0)
            break;
        n++;
        // See https://elixir.bootlin.com/linux/v5.19.17/source/include/uapi/linux/auxvec.h
        switch (stackp[idx]) {
            case 0x19:  // AT_RANDOM
                stack_sparep = (void *)stackp[idx + 1] + 16;
            case 0x1f:  // AT_EXECFN, static=outside, dynamic=inside
                // DEBUGF("0x1f %s\n", &stack[stackp[idx + 1] - SP(regs)]);
            case 0x21:  // ptr to "\177ELF\002\001\001\000", normally outside stack region.
            case 0x0f:  // AT_PLATFORM
            case 0x18:  // AT_BASE_PLATFORM
                if (stackp[idx + 1] == 0)
                    break; // Value is NULL (not set)
                if (stackp[idx + 1] - SP(*regsp) > stack_sz) {
                    DEBUGF("[0x%02x] Value outside of fake stack: 0x%lx\n", (unsigned int)stackp[idx], stackp[idx + 1]);
                    break; // Address is at higher address that wasnt moved.
                }
                // DEBUGF("Adjusting 0x%02x [%s]\n", (unsigned int)stackp[idx], &stack[stackp[idx + 1] - SP(*regsp)]);
                stackp[idx + 1] -= len;
                break;
        }
    }

    // Stack randomization gives us some free space (zapper currently does not use this).
    if (stack_sparep != NULL)
        stack_spare_sz = stackp[1] - (long unsigned int)stack_sparep;
    DEBUGF("Spare stack space: %zu 0x%p-0x%p\n", stack_spare_sz, stack_sparep, (void *)stackp[1]);

    // Adjust address off all argv-pointers
    int i = 1;  // i = 0 is ARGC
    while (stackp[i] != 0)
        stackp[i++] -= len;

    if (g_flags & FL_ZAP_ENV) {
        i = 0;
        while (stack_envp[i] != 0)
            stack_envp[i++] -= len;
    }

    i = 1;
    idx = stack_sz - len;
    // Delete all argv-strings that the kernel references
    memset(&stack[stack_sz - len], 0, len);
    // Copy the program's name to argv[0] that the kernel references
    memcpy(&stack[idx], g_prg_name, strlen(g_prg_name));
    // write the new stack
    ptpokecpy(pid, (void *)(SP(*regsp) - len), stack, stack_sz);
    free(stack);

    // Increase the stack size (by decreasing the stack pointer).
    SP(*regsp) -= len;
    ptrace(PTRACE_SETREGS, pid, NULL, regsp);
}

static void
follow_forever(pid_t pid)
{
    int status;
    struct user_regs_struct regs;

    while (ptrace_until_execve(&pid, &regs, &status) > 0) {
        fix_stack(pid, &regs);
    }    
    exit(255);
}

// Trap at ELF's AT_ENTRY
static pid_t
start_trace(const char *orig_prog, char *new_argv[], struct user_regs_struct *regsp) {
    pid_t pid;

    if (!(g_flags & FL_FOLLOW)) {
        // Detach after zapping if we are a background process.
        if (fcntl(0, F_GETFD, 0) != 0) {
            // STDIN is closed. Assume I'm a background process.
            g_flags &= ~FL_STAY_ATTACHED;
        } else {
            // STDIN is open
            if (getpid() != tcgetpgrp(0))
                g_flags &= ~FL_STAY_ATTACHED;  // Got started as background process by shell
        }
    }

    // Try for the CHILD to be the TRACER and trace this process.
    if (!(g_flags & FL_FORCE_TRACER_IS_PARENT)) {
        pid = start_trace_parent(orig_prog, new_argv, regsp);
        if (pid > 0) {
            DEBUGF("Trapped PARENT pid %d\n", pid);
            if (!(g_flags & FL_FOLLOW))
                g_flags &= ~FL_STAY_ATTACHED;
            goto done;  // We are now the CHILD.
        }
        DEBUGF("ERROR: TRACER failed to be the PARENT\n");
        // FIXME: try with -c parameter
    }

    // ### This PARENT is the TRACER and tracing the CHILD (TRACEE)
    // Must always stay attached even if background process in case caller checks $!
    g_flags |= FL_STAY_ATTACHED;
    pid = start_trace_child(orig_prog, new_argv);
    DEBUGF("[%d] Tracing child %d\n", getpid(), pid);
    XFAIL(ptrace(PTRACE_GETREGS, pid, NULL, regsp) != 0, "ptrace(%d): %s\n", pid, strerror(errno));
done:
    return pid;
}

int
main(int argc, char *argv[], char *envp[]) {
    pid_t pid;
    struct user_regs_struct regs;
    int i;

    init_vars();
    do_getopts(argc, argv);

    pid = start_trace(argv[optind], &argv[optind], &regs);

    fix_stack(pid, &regs);

    // TRACEE is a background process _OR_ TRACER is the child process
    if (!(g_flags & FL_STAY_ATTACHED)) {
        ptrace(PTRACE_DETACH, pid, NULL, NULL);
        DEBUGF("All done. Tracer exiting....\n");
        exit(0);
    }

    // Destroy my own argv
    for (i = 1; i < argc; i++)
        memset(argv[i], 0, strlen(argv[i]));

    // Destroy my own envp    
    if (g_flags & FL_ZAP_ENV) {
        for (i = 0; envp[i] != NULL; i++)
            memset(envp[i], 0, strlen(envp[i]));
    }

    if (g_flags & FL_FOLLOW) {
        DEBUGF("FOLLOWING...\n");
        follow_forever(pid);
        exit(255);  // NOT REACHED.
    }

    ptrace(PTRACE_DETACH, pid, NULL, NULL);

    // FIXME: Parent (tracer) needs to proxy all signals to child (tracee).
    // Wait for child to terminate
    waitpid(pid, &i, 0);
    if (WIFEXITED(i))
        exit(WEXITSTATUS(i));
    exit(255); // NOT REACHED
}

